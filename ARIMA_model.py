#!/usr/bin/env python
# coding: utf-8

# In[2]:


import warnings    

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import xlrd

from matplotlib.pylab import style

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller as ADF
from statsmodels.stats.diagnostic import acorr_ljungbox
import statsmodels.api as sm
from statsmodels.graphics.api import qqplot
from statsmodels.tsa.arima_model import ARIMA

from sklearn.metrics import mean_absolute_error
from sklearn.metrics import r2_score


# In[3]:


style.use('ggplot')

# import training data
filename = 'procedure_imported_data/data (2005-2015).xls'
disease = pd.read_excel(filename, index_col='date')

# import complete data
full_value_name = 'procedure_imported_data/data (2005-2017).xls'
observed_value = pd.read_excel(full_value_name, index_col='date')

# draw the time sequence diagram
plt.plot(disease)
plt.xlabel('Date')
plt.ylabel('Rate')
plt.legend(loc='upper left')
plt.savefig('Original sequence (2005-2015).pdf', dpi=300)

# stability test (p<0.05 indicates a smooth series)
print("The ADF test results for the original series are " + str(ADF(disease['Observed value'])))


# In[21]:


sm.graphics.tsa.plot_acf(disease['Observed value'], lags=36)
plt.ylabel('Correlation Coefficients')
plt.xlabel('Lags')
plt.tight_layout()
plt.savefig('data-acf.pdf', dpi=300)

sm.graphics.tsa.plot_pacf(disease['Observed value'], lags=36)
plt.ylabel('Correlation Coefficients')
plt.xlabel('Lags')
plt.tight_layout()
plt.savefig('data-pacf.pdf', dpi=300)


# In[18]:


# first-order difference and smoothness tests
d1_disease = disease['Observed value'].diff(periods=1).dropna()
plt.plot(d1_disease)

plt.xlabel('Date')
plt.ylabel('Rate')
plt.legend(loc='upper left')
plt.savefig('first-order difference (2005-2015).svg', dpi=300)

print("The ADF test for the series after first-order differencing is " + str(ADF(d1_disease)))


# In[8]:


# white noise test (p<0.05 indicates non-white noise)
print("The results of the white noise test for the first-order difference series are " + str(acorr_ljungbox(d1_disease, lags=1)))
plt.show()


# In[22]:


warnings.filterwarnings("ignore") 

# BIC parameter tuning
pmax = 5
qmax = 5
bic_value = []
for p in range(pmax+1):
    tmp = []
    for q in range(qmax+1):
        try:
            tmp.append(ARIMA(disease, (p, 1, q)).fit().bic)
        except:
            tmp.append(None)
    bic_value.append(tmp)

bic_value = pd.DataFrame(bic_value)
bic_value = bic_value.round(2)


# In[23]:


sns.heatmap(bic_value, square=False, linewidths=.5, annot=True, fmt='.2f') 
p, q = bic_value.stack().astype(float).idxmin()
print("Optimal p value is %d, q value is %d"%(p, q))

plt.savefig('BIC heatmap.png', dpi=800)


# In[24]:


warnings.filterwarnings("ignore") 

# AIC parameter tuning
pmax = 5
qmax = 5
aic_value = []
for p in range(pmax+1):
    tmp = []
    for q in range(qmax+1):
        try:
            tmp.append(ARIMA(disease, (p, 1, q)).fit().aic)
        except:
            tmp.append(None)
    aic_value.append(tmp)

aic_value = pd.DataFrame(aic_value)


# In[25]:


sns.heatmap(aic_value, square=False, linewidths=.5, annot=True, fmt='.2f') #热力图
p, q = aic_value.stack().astype(float).idxmin()
print("Optimal p value is %d, q value is %d"%(p, q))

plt.savefig('AIC heatmap.png', dpi=800)


# In[23]:


model = ARIMA(disease, order=(2,1,4)).fit(disp=-1, method='css')
model.summary()

# residual test
resid = model.resid

# QQ plot
qqplot(resid, line='q', fit=True)
plt.savefig('QQ plot.pdf', dpi=300)


# D-W test
print("D-W testing results: ", sm.stats.durbin_watson(resid.values))

# LB test
print("White noise test results for first-order difference series：" + str(acorr_ljungbox(resid, lags=1)))

sm.graphics.tsa.plot_acf(resid, lags=36)
plt.ylabel('Correlation Coefficients')
plt.xlabel('Lags')
plt.tight_layout()
plt.savefig('ARIMA-acf.pdf', dpi=300)

sm.graphics.tsa.plot_pacf(resid, lags=36)
plt.ylabel('Correlation Coefficients')
plt.xlabel('Lags')
plt.tight_layout()
plt.savefig('ARIMA-pacf.pdf', dpi=300)


# In[10]:

# predicted values were generated by SPSS software
filename = 'procedure_imported_data/observed and predicted values.xls'
disease = pd.read_excel(filename)

# 24-steps
true = disease['Observed value']
pred = disease['Predicted value']

# calculation errors (RMSE, MAE, MAPE, and sMAPE)
mse = ((pred - true) ** 2).mean()
print('RMSE is {:.4f}'.format(np.sqrt(mse)))
mae = mean_absolute_error(true, pred)
print('MAE is {:.4f}'.format(mae))
mape = np.mean(np.abs((true - pred) / true)) * 100
print('MAPE is {:.4f}'.format(mape))
smape = 2.0 * np.mean(np.abs(true - pred) / (np.abs(true) + np.abs(pred))) * 100
print('SMAPE is {:.4f}'.format(smape))


# In[11]:


# 12-steps
true = disease['Observed value'][:12]
pred = disease['Predicted value'][:12]

# calculation errors (RMSE, MAE, MAPE, and sMAPE)
mse = ((pred - true) ** 2).mean()
print('RMSE is {:.4f}'.format(np.sqrt(mse)))
mae = mean_absolute_error(true, pred)
print('MAE is {:.4f}'.format(mae))
mape = np.mean(np.abs((true - pred) / true)) * 100
print('MAPE is {:.4f}'.format(mape))
smape = 2.0 * np.mean(np.abs(true - pred) / (np.abs(true) + np.abs(pred))) * 100
print('SMAPE is {:.4f}'.format(smape))


# In[12]:


# 6-steps
true = disease['Observed value'][:6]
pred = disease['Predicted value'][:6]

# calculation errors (RMSE, MAE, MAPE, and sMAPE)
mse = ((pred - true) ** 2).mean()
print('RMSE is {:.4f}'.format(np.sqrt(mse)))
mae = mean_absolute_error(true, pred)
print('MAE is {:.4f}'.format(mae))
mape = np.mean(np.abs((true - pred) / true)) * 100
print('MAPE is {:.4f}'.format(mape))
smape = 2.0 * np.mean(np.abs(true - pred) / (np.abs(true) + np.abs(pred))) * 100
print('SMAPE is {:.4f}'.format(smape))


# In[13]:


# Re-import data
filename = 'procedure_imported_data/ARIMA_prediction.xls'
data = pd.read_excel(filename, index_col='Date')
forecast = data['2016-01-01':]['Predicted value']
print(forecast)
prediction = data['2005-02-01':'2015-12-01']['Predicted value']
print(prediction)
lcl = data['2016-01-01':]['LCL']
ucl = data['2016-01-01':]['UCL']

# time series chart
ax = observed_value.plot(label='Observed value')
forecast.plot(ax=ax, label='ARIMA predicted value')
prediction.plot(ax=ax, label='Fit value')

ax.fill_between(forecast.index, lcl, ucl, color='k', alpha=.2)

ax.fill_betweenx(ax.get_ylim(), pd.to_datetime('2016-01-01'), observed_value.index[-1], alpha=.1, zorder=-1)

ax.set_xlabel('Date')
ax.set_ylabel('Rate')
plt.legend(loc='upper left')
plt.ylim(0, 16)

plt.savefig('ARIMA prediction.pdf', dpi=600)

plt.show()

